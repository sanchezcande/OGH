{"version":3,"file":"static/js/235.72b882b0.chunk.js","mappings":"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","sources":["../node_modules/react-use-gesture/src/utils/math.ts","../node_modules/react-use-gesture/src/utils/rubberband.ts","../node_modules/react-use-gesture/src/utils/utils.ts","../node_modules/react-use-gesture/src/utils/resolveOptionsWith.ts","../node_modules/react-use-gesture/src/utils/event.ts","../node_modules/react-use-gesture/src/utils/config.ts","../node_modules/react-use-gesture/src/utils/state.ts","../node_modules/react-use-gesture/src/recognizers/Recognizer.ts","../node_modules/react-use-gesture/src/Controller.ts","../node_modules/react-use-gesture/src/hooks/useRecognizers.ts","../node_modules/react-use-gesture/src/recognizers/CoordinatesRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/DragRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/PinchRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/DistanceAngleRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/WheelRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/MoveRecognizer.ts","../node_modules/react-use-gesture/src/recognizers/ScrollRecognizer.ts","../node_modules/react-use-gesture/src/hooks/useGesture.ts","../node_modules/react-use-gesture/src/hooks/buildConfig.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\ninterface Kinematics {\n  velocities: number[]\n  velocity: number\n  distance: number\n  direction: number[]\n}\n\nexport function calculateAllGeometry<T extends number[]>(movement: T, delta: T = movement) {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n\n  const direction = delta.map(v => alpha * v) as T\n  const distance = calculateDistance(movement)\n\n  return { distance, direction }\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, dt: number): Kinematics {\n  const dl = calculateDistance(delta)\n\n  const alpha = dl === 0 ? 0 : 1 / dl\n  const beta = dt === 0 ? 0 : 1 / dt\n\n  const velocity = beta * dl\n  const velocities = delta.map(v => beta * v)\n  const direction = delta.map(v => alpha * v)\n  const distance = calculateDistance(movement)\n\n  return { velocities, velocity, distance, direction }\n}\n\n/**\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\n * This polyfill function is suggested by Mozilla:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\n * @param x target number\n */\nexport function sign(x: number) {\n  if (Math.sign) return Math.sign(x)\n  return Number(x > 0) - Number(x < 0) || +x\n}\n","function minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n  if (position < min) return -rubberband(min - position, max - min, constant) + min\n  if (position > max) return +rubberband(position - max, max - min, constant) + max\n  return position\n}\n","export function noop() {}\n\n/**\n * TODO Beware that only optimized cases are covered in tests =)\n * TODO Need to cover general case as well\n *\n * @param fns\n */\nexport function chainFns(...fns: Function[]): Function {\n  if (fns.length === 0) return noop\n  if (fns.length === 1) return fns[0]\n\n  return function (this: any) {\n    var result\n    for (let fn of fns) {\n      result = fn.apply(this, arguments) || result\n    }\n    return result\n  }\n}\n\n/**\n * Expects a simple value or 2D vector (an array with 2 elements) and\n * always returns 2D vector. If simple value is passed, returns a\n * vector with this value as both coordinates.\n *\n * @param value\n */\nexport function ensureVector<T>(value: T | [T, T] | undefined, fallback?: T | [T, T]): [T, T] {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected')\n    }\n    value = fallback\n  }\n\n  if (Array.isArray(value)) return value\n  return [value, value]\n}\n\n/**\n * Helper for defining a default value\n *\n * @param value\n * @param fallback\n */\nexport function assignDefault<T extends Object>(value: Partial<T> | undefined, fallback: T): T {\n  return Object.assign({}, fallback, value || {})\n}\n\n/**\n * Resolves getters (functions) by calling them\n * If simple value is given it just passes through\n *\n * @param v\n */\nexport function valueFn<T>(v: T | ((...args: any[]) => T), ...args: any[]): T {\n  if (typeof v === 'function') {\n    // @ts-ignore\n    return v(...args)\n  } else {\n    return v\n  }\n}\n","export type Resolver = (x: any, key: string, obj: object) => any\nexport type ResolverMap = { [k: string]: Resolver | ResolverMap | boolean }\n\nexport function resolveWith<T extends { [k: string]: any }, V extends { [k: string]: any }>(\n  config: Partial<T> = {},\n  resolvers: ResolverMap\n): V {\n  const result: any = {}\n\n  for (const [key, resolver] of Object.entries(resolvers))\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config)\n        break\n      case 'object':\n        result[key] = resolveWith(config[key], resolver)\n        break\n      case 'boolean':\n        if (resolver) result[key] = config[key]\n        break\n    }\n\n  return result\n}\n","import { Vector2, WebKitGestureEvent, DomEvents } from '../types'\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport function supportsTouchEvents(): boolean {\n  return typeof window !== 'undefined' && 'ontouchstart' in window\n}\n\nexport function supportsPointerEvents(): boolean {\n  return typeof window !== 'undefined' && 'onpointerdown' in window\n}\n\nfunction getEventTouches(event: PointerEvent | React.PointerEvent | TouchEvent | React.TouchEvent) {\n  if ('pointerId' in event) return null\n  return event.type === 'touchend' ? event.changedTouches : event.targetTouches\n}\n\nexport function getTouchIds(event: TouchEvent | React.TouchEvent): number[] {\n  return Array.from(getEventTouches(event)!).map(t => t.identifier)\n}\n\nexport function getGenericEventData(event: DomEvents) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const { shiftKey, altKey, metaKey, ctrlKey } = event as any // TODO check if this might create some overrides?\n  return { buttons, shiftKey, altKey, metaKey, ctrlKey }\n}\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(\n  event: TouchEvent | React.TouchEvent | React.PointerEvent | PointerEvent,\n  transform = identity\n): Vector2 {\n  const touchEvents = getEventTouches(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return transform([clientX, clientY])\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventValues(\n  event: React.TouchEvent | TouchEvent,\n  pointerIds: [number, number],\n  transform = identity\n) {\n  const [A, B] = Array.from(event.touches).filter(t => pointerIds.includes(t.identifier))\n\n  if (!A || !B) throw Error(`The event doesn't have two pointers matching the pointerIds`)\n\n  const dx = B.clientX - A.clientX\n  const dy = B.clientY - A.clientY\n  const cx = (B.clientX + A.clientX) / 2\n  const cy = (B.clientY + A.clientY) / 2\n\n  // const e: any = 'nativeEvent' in event ? event.nativeEvent : event\n\n  const distance = Math.hypot(dx, dy)\n  // FIXME rotation has inconsistant values so we're not using it atm\n  // const angle = (e.rotation as number) ?? -(Math.atan2(dx, dy) * 180) / Math.PI\n  const angle = -(Math.atan2(dx, dy) * 180) / Math.PI\n  const values: Vector2 = transform([distance, angle])\n  const origin: Vector2 = transform([cx, cy])\n\n  return { values, origin }\n}\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: React.UIEvent | UIEvent, transform = identity): Vector2 {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return transform([scrollX || scrollLeft || 0, scrollY || scrollTop || 0])\n}\n\n// wheel delta defaults from https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js\nconst LINE_HEIGHT = 40\nconst PAGE_HEIGHT = 800\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: React.WheelEvent | WheelEvent, transform = identity): Vector2 {\n  let { deltaX, deltaY, deltaMode } = event\n  // normalize wheel values, especially for Firefox\n  if (deltaMode === 1) {\n    deltaX *= LINE_HEIGHT\n    deltaY *= LINE_HEIGHT\n  } else if (deltaMode === 2) {\n    deltaX *= PAGE_HEIGHT\n    deltaY *= PAGE_HEIGHT\n  }\n  return transform([deltaX, deltaY])\n}\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent, transform = identity): Vector2 {\n  return transform([event.scale, event.rotation])\n}\n","import { ensureVector, assignDefault, valueFn } from './utils'\nimport { resolveWith } from './resolveOptionsWith'\n\nimport {\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n  Vector2,\n  Bounds,\n  StateKey,\n  State,\n  CoordinatesKey,\n  DistanceAngleKey,\n} from '../types'\nimport { supportsTouchEvents, supportsPointerEvents } from './event'\n\nexport const DEFAULT_DRAG_DELAY = 180\nexport const DEFAULT_RUBBERBAND = 0.15\nexport const DEFAULT_SWIPE_VELOCITY = 0.5\nexport const DEFAULT_SWIPE_DISTANCE = 50\nexport const DEFAULT_SWIPE_DURATION = 250\n\nconst InternalGestureOptionsNormalizers = {\n  threshold(value: number | Vector2 = 0) {\n    return ensureVector(value)\n  },\n\n  rubberband(value: number | boolean | Vector2 = 0): Vector2 {\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND)\n      case false:\n        return ensureVector(0)\n      default:\n        return ensureVector(value)\n    }\n  },\n\n  enabled(value = true) {\n    return value\n  },\n\n  triggerAllEvents(value = false) {\n    return value\n  },\n\n  initial(value = 0) {\n    if (typeof value === 'function') return value\n    return ensureVector(value)\n  },\n\n  transform: true,\n}\n\nconst InternalCoordinatesOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n  axis: true,\n  lockDirection(value = false) {\n    return value\n  },\n  bounds(value: Bounds | ((state?: State) => Bounds) = {}) {\n    if (typeof value === 'function')\n      return (state?: State) => InternalCoordinatesOptionsNormalizers.bounds(value(state))\n\n    const { left = -Infinity, right = Infinity, top = -Infinity, bottom = Infinity } = value\n\n    return [\n      [left, right],\n      [top, bottom],\n    ]\n  },\n}\n\nconst isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement\n\nconst InternalGenericOptionsNormalizers = {\n  enabled(value = true) {\n    return value\n  },\n  domTarget: true,\n  window(value = isBrowser ? window : undefined) {\n    return value\n  },\n  eventOptions({ passive = true, capture = false } = {}) {\n    return { passive, capture }\n  },\n  transform: true,\n}\n\nconst InternalDistanceAngleOptionsNormalizers = {\n  ...InternalGestureOptionsNormalizers,\n\n  bounds(_value: undefined, _key: string, { distanceBounds = {}, angleBounds = {} }) {\n    const _distanceBounds = (state?: State) => {\n      const D = assignDefault(valueFn(distanceBounds, state), { min: -Infinity, max: Infinity })\n      return [D.min, D.max]\n    }\n\n    const _angleBounds = (state?: State) => {\n      const A = assignDefault(valueFn(angleBounds, state), { min: -Infinity, max: Infinity })\n      return [A.min, A.max]\n    }\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function')\n      return [_distanceBounds(), _angleBounds()]\n\n    return (state?: State) => [_distanceBounds(state), _angleBounds(state)]\n  },\n}\n\nconst InternalDragOptionsNormalizers = {\n  ...InternalCoordinatesOptionsNormalizers,\n\n  useTouch(value = false) {\n    const supportsTouch = supportsTouchEvents()\n    const supportsPointer = supportsPointerEvents()\n    if (value && supportsTouch) return true\n    if (supportsTouch && !supportsPointer) return true\n    return false\n  },\n  experimental_preventWindowScrollY(value = false) {\n    return value\n  },\n  threshold(\n    this: InternalDragOptions,\n    v: number | Vector2 | undefined,\n    _k: string,\n    { filterTaps = false, lockDirection = false, axis = undefined }\n  ) {\n    const A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0) as Vector2\n    this.filterTaps = filterTaps\n    return A\n  },\n\n  swipeVelocity(v: number | Vector2 = DEFAULT_SWIPE_VELOCITY) {\n    return ensureVector(v)\n  },\n  swipeDistance(v: number | Vector2 = DEFAULT_SWIPE_DISTANCE) {\n    return ensureVector(v)\n  },\n  swipeDuration(value = DEFAULT_SWIPE_DURATION) {\n    return value\n  },\n  delay(value: number | boolean = 0) {\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY\n      case false:\n        return 0\n      default:\n        return value\n    }\n  },\n}\n\nexport function getInternalGenericOptions(config: GenericOptions = {}): InternalGenericOptions {\n  // TODO warn when passive is set to true and domTarget is undefined\n  return resolveWith<GenericOptions, InternalGenericOptions>(config, InternalGenericOptionsNormalizers)\n}\n\nexport function getInternalGestureOptions<T extends StateKey>(\n  config: GestureOptions<T> = {}\n): InternalGestureOptions<T> {\n  return resolveWith<GestureOptions<T>, InternalGestureOptions<T>>(config, InternalGestureOptionsNormalizers)\n}\n\nexport function getInternalCoordinatesOptions<T extends CoordinatesKey>(\n  config: CoordinatesConfig<T> = {}\n): InternalCoordinatesOptions<T> {\n  return resolveWith<CoordinatesConfig<T>, InternalCoordinatesOptions<T>>(config, InternalCoordinatesOptionsNormalizers)\n}\n\nexport function getInternalDistanceAngleOptions<T extends DistanceAngleKey>(\n  config: DistanceAngleConfig<T> = {}\n): InternalDistanceAngleOptions<T> {\n  return resolveWith<DistanceAngleConfig<T>, InternalDistanceAngleOptions<T>>(\n    config,\n    InternalDistanceAngleOptionsNormalizers\n  )\n}\n\nexport function getInternalDragOptions(config: DragConfig = {}): InternalDragOptions {\n  return resolveWith<DragConfig, InternalDragOptions>(config, InternalDragOptionsNormalizers)\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2, DragState, PinchState } from '../types'\n\nfunction getInitial<T>(mixed: T): T & CommonGestureState {\n  return {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [\n      [-Infinity, Infinity],\n      [-Infinity, Infinity],\n    ],\n    _threshold: [0, 0],\n    _lastEventType: undefined,\n    _dragStarted: false,\n    _dragPreventScroll: false,\n    _dragIsTap: true,\n    _dragDelayed: false,\n    event: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n    ...mixed,\n  }\n}\n\nexport function getInitialState(): State {\n  const shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false,\n    locked: false,\n  }\n\n  const drag = getInitial<DragState & Coordinates>({\n    _pointerId: undefined,\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n    tap: false,\n    swipe: [0, 0],\n  })\n\n  const pinch = getInitial<DistanceAngle & PinchState>({\n    // @ts-expect-error when used _pointerIds we can assert its type will be [number, number]\n    _pointerIds: [],\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    // @ts-expect-error origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0,\n  })\n\n  const wheel = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const move = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  const scroll = getInitial<Coordinates>({\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  })\n\n  return { shared, drag, pinch, wheel, move, scroll }\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  IngKey,\n  InternalConfig,\n  GestureKey,\n  GestureState,\n  EventTypes,\n  PartialGestureState,\n  Vector2,\n  FullGestureState,\n  RecognizerClass,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { rubberbandIfOutOfBounds } from '../utils/rubberband'\nimport { subV, addV, sign } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\nexport const RecognizersMap = new Map<GestureKey, RecognizerClass>()\n\nconst identity = (xy: Vector2) => xy\n\n/**\n * @private\n * Recognizer abstract class.\n */\nexport default abstract class Recognizer<T extends StateKey = StateKey> {\n  abstract readonly ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n  abstract readonly stateKey: T\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(readonly controller: Controller, readonly args: any[] = []) {\n    this.controller = controller\n    this.args = args\n  }\n\n  // Returns the gesture config\n  get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  get transform() {\n    return this.config.transform || this.controller.config.transform || identity\n  }\n\n  // Convenience method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Convenience method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  protected abstract getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T>\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  protected abstract mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'>\n\n  public abstract addBindings(bindings: any): void\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2): PartialGestureState<T> {\n    const { rubberband } = this.config\n\n    const {\n      _bounds,\n      _initial,\n      _active,\n      _intentional: wasIntentional,\n      lastOffset,\n      movement: prevMovement,\n      _threshold: _T,\n    } = this.state\n    const M = this.getInternalMovement(values, this.state)\n\n    const i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], _T[0]) : wasIntentional[0]\n    const i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], _T[1]) : wasIntentional[1]\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], M)\n    if (intentionalityCheck._blocked) {\n      return { ...intentionalityCheck, _movement: M, delta: [0, 0] }\n    }\n\n    const _intentional = intentionalityCheck._intentional!\n    const _movement = M\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement: Vector2 = [\n      _intentional[0] !== false ? M[0] - _intentional[0] : 0,\n      _intentional[1] !== false ? M[1] - _intentional[1] : 0,\n    ]\n\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband)\n\n    return {\n      ...intentionalityCheck,\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial,\n      _movement,\n      movement,\n      values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n  }\n\n  /**\n   * Fires the gesture handler\n   */\n  protected fireGestureHandler = (forceFlag: boolean = false): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't fire the handler.\n    if (!forceFlag && !this.state.intentional && !this.config.triggerAllEvents) return null\n\n    if (this.state.intentional) {\n      const prev_active = this.state.active\n      const next_active = this.state._active\n\n      this.state.active = next_active\n      this.state.first = next_active && !prev_active\n      this.state.last = prev_active && !next_active\n\n      this.controller.state.shared[this.ingKey] = next_active // Sets dragging, pinching, etc. to the gesture active state\n    }\n    const touches = this.controller.pointerIds.size || this.controller.touchIds.size\n    const down = this.controller.state.shared.buttons > 0 || touches > 0\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n      locked: !!document.pointerLockElement,\n      touches,\n      down,\n    } as FullGestureState<T>\n\n    // @ts-expect-error\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    return state\n  }\n}\n\n//--------------------------------------------\n\nfunction getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold\n  } else {\n    return false\n  }\n}\n\nfunction computeRubberband(bounds: [Vector2, Vector2], [Vx, Vy]: Vector2, [Rx, Ry]: Vector2): Vector2 {\n  const [[X1, X2], [Y1, Y2]] = bounds\n\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)]\n}\n\n/**\n * Returns a generic, common payload for all gestures from an event.\n */\nexport function getGenericPayload<T extends StateKey>(\n  { state }: Recognizer<T>,\n  event: EventTypes[T],\n  isStartEvent?: boolean\n) {\n  const { timeStamp, type: _lastEventType } = event\n  const previous = state.values\n  const elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime!\n  return { _lastEventType, event, timeStamp, elapsedTime, previous }\n}\n\n/**\n * Returns the reinitialized start state for the gesture.\n * Should be common to all gestures.\n */\nexport function getStartGestureState<T extends StateKey>(\n  { state, config, stateKey, args, transform }: Recognizer<T>,\n  values: Vector2,\n  event: EventTypes[T],\n  initial?: Vector2\n) {\n  const offset = state.offset\n  const startTime = event.timeStamp\n\n  const { initial: initialFn, bounds, threshold } = config\n\n  // the _threshold is the difference between a [0,0] offset converted to\n  // its new space coordinates\n  const _threshold = subV(transform(threshold), transform([0, 0])).map(Math.abs)\n\n  const _state = {\n    ...getInitialState()[stateKey],\n    _active: true,\n    args,\n    values,\n    initial: initial ?? values,\n    _threshold,\n    offset,\n    lastOffset: offset,\n    startTime,\n  }\n\n  return { ..._state, _initial: valueFn(initialFn, _state), _bounds: valueFn(bounds, _state) }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n  RecognizerClass,\n} from './types'\nimport { supportsTouchEvents, supportsGestureEvents, getTouchIds } from './utils/event'\nimport { getInitialState } from './utils/state'\nimport { chainFns } from './utils/utils'\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n */\nexport default class Controller {\n  public nativeRefs!: any\n  public config!: InternalConfig\n  public handlers!: InternalHandlers\n  public state: State // state for all gestures\n  public timeouts: { [stateKey in StateKey]?: number } // tracks timeouts of debounced gestures\n  public domListeners: [string, Fn][] // when config.domTarget is set, we attach events directly to the dom\n  public windowListeners: { [stateKey in StateKey]?: [string, Function][] } // keeps track of window listeners added by gestures (drag only at the moment)\n\n  public pointerIds = new Set<number>() // register Pointer Events pointerIds\n  public touchIds = new Set<number>() // register Touch Events identifiers\n  public supportsTouchEvents = supportsTouchEvents()\n  public supportsGestureEvents = supportsGestureEvents()\n\n  constructor(private classes: Set<RecognizerClass>) {\n    this.classes = classes\n    this.state = getInitialState()\n    this.timeouts = {}\n    this.domListeners = []\n    this.windowListeners = {}\n  }\n\n  public bind = (...args: any[]) => {\n    const bindings: { [key: string]: Function[] } = {}\n\n    for (let RecognizerClass of this.classes) new RecognizerClass(this, args).addBindings(bindings)\n\n    // // we also add event bindings for native handlers\n    for (let eventKey in this.nativeRefs) {\n      addBindings(bindings, eventKey, (event: any) => this.nativeRefs[eventKey]({ ...this.state.shared, event, args }))\n    }\n\n    if (this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(this, bindings)\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(this, bindings)\n    }\n  }\n\n  public effect = () => {\n    if (this.config.domTarget) this.bind()\n    return this.clean\n  }\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    const domTarget = getDomTargetFromConfig(this.config)\n    const { eventOptions } = this.config\n    if (domTarget) removeListeners(domTarget, takeAll(this.domListeners), eventOptions)\n    Object.values(this.timeouts).forEach(clearTimeout)\n    clearAllWindowListeners(this)\n  }\n}\n\nexport function addEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.add(event.pointerId)\n  } else {\n    controller.touchIds = new Set(getTouchIds(event))\n  }\n}\n\nexport function removeEventIds(\n  controller: Controller,\n  event: React.TouchEvent | TouchEvent | React.PointerEvent | PointerEvent\n) {\n  if ('pointerId' in event) {\n    controller.pointerIds.delete(event.pointerId)\n  } else {\n    getTouchIds(event).forEach(id => controller.touchIds.delete(id))\n  }\n}\n\nexport function clearAllWindowListeners(controller: Controller) {\n  const {\n    config: { window: el, eventOptions },\n    windowListeners,\n  } = controller\n  if (!el) return\n\n  for (let stateKey in windowListeners) {\n    const handlers = windowListeners[stateKey as StateKey]\n    removeListeners(el, handlers, eventOptions)\n  }\n\n  controller.windowListeners = {}\n}\n\nexport function clearWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  delete windowListeners[stateKey]\n}\n\nexport function updateWindowListeners(\n  { config, windowListeners }: Controller,\n  stateKey: StateKey,\n  listeners: [string, Fn][] = [],\n  options = config.eventOptions\n) {\n  if (!config.window) return\n  removeListeners(config.window, windowListeners[stateKey], options)\n  addListeners(config.window, (windowListeners[stateKey] = listeners), options)\n}\n\nfunction updateDomListeners({ config, domListeners }: Controller, bindings: { [key: string]: Function[] }) {\n  const domTarget = getDomTargetFromConfig(config)\n  if (!domTarget) throw new Error('domTarget must be defined')\n  const { eventOptions } = config\n\n  removeListeners(domTarget, takeAll(domListeners), eventOptions)\n\n  for (let [key, fns] of Object.entries(bindings)) {\n    const name = key.slice(2).toLowerCase()\n    domListeners.push([name, chainFns(...fns)])\n  }\n\n  addListeners(domTarget, domListeners, eventOptions)\n}\n\nfunction getPropsListener({ config }: Controller, bindings: { [key: string]: Function[] }) {\n  const props: ReactEventHandlers = {}\n  const captureString = config.eventOptions.capture ? 'Capture' : ''\n  for (let [event, fns] of Object.entries(bindings)) {\n    const fnsArray = Array.isArray(fns) ? fns : [fns]\n    const key = (event + captureString) as ReactEventHandlerKey\n    props[key] = chainFns(...(fnsArray as Fn[]))\n  }\n  return props\n}\n\nfunction takeAll<T>(array: Array<T> = []) {\n  return array.splice(0, array.length)\n}\n\nfunction getDomTargetFromConfig({ domTarget }: InternalConfig) {\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n}\n\n/**\n * bindings is an object which keys match ReactEventHandlerKeys.\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n * that key.\n */\nexport function addBindings(bindings: any, name: string, fn: Fn): void {\n  if (!bindings[name]) bindings[name] = []\n  bindings[name]!.push(fn)\n}\n\nfunction addListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.addEventListener(eventName, eventHandler, options)\n  }\n}\n\nfunction removeListeners(el: EventTarget, listeners: Array<[string, Fn]> = [], options = {}) {\n  for (let [eventName, eventHandler] of listeners) {\n    el.removeEventListener(eventName, eventHandler, options)\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  GenericOptions,\n  RecognizerClass,\n  NativeHandlers,\n} from '../types'\n\n/**\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param handlers\n * @param classes\n * @param config\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  config: InternalConfig,\n  nativeHandlers: Partial<NativeHandlers> = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const classes = resolveClasses(handlers)\n\n  const controller = React.useMemo(() => new Controller(classes), [])\n  controller!.config = config\n  controller!.handlers = handlers\n  controller!.nativeRefs = nativeHandlers\n\n  React.useEffect(controller.effect, [])\n\n  // @ts-ignore\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget\n  // @ts-ignore\n  return controller.bind\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Deprecation notice: When the \\`domTarget\\` option is specified, you don't need to write \\`useEffect(bind, [bind])\\` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when \\`domTarget\\` is provided, therefore your code will break if you try to call \\`useEffect\\`.`\n    )\n  }\n}\n\nfunction resolveClasses(internalHandlers: Partial<InternalHandlers>) {\n  const classes = new Set<RecognizerClass>()\n\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag')!)\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel')!)\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll')!)\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move')!)\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch')!)\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover')!)\n\n  return classes\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into account)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   */\n  protected checkIntentionality(\n    _intentional: [false | number, false | number],\n    _movement: Vector2\n  ): PartialGestureState<T> {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return { _intentional, axis: this.state.axis } as PartialGestureState<T>\n    }\n    const [absX, absY] = _movement.map(Math.abs)\n    const axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n    if (!this.config.axis && !this.config.lockDirection) return { _intentional, _blocked: false, axis } as any\n    if (!axis) return { _intentional: [false, false], _blocked: false, axis } as any\n    if (!!this.config.axis && axis !== this.config.axis) return { _intentional, _blocked: true, axis } as any\n    _intentional![axis === 'x' ? 1 : 0] = false\n    return { _intentional, _blocked: false, axis } as any\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    if (!state._blocked) {\n      const dt = event.timeStamp - this.state.timeStamp!\n      Object.assign(state, calculateAllKinematics(state.movement!, state.delta!, dt))\n    }\n    return state\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { xy: state.values, vxvy: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, sign } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, updateWindowListeners, clearWindowListeners, addEventIds, removeEventIds } from '../Controller'\n\nexport const TAP_DISTANCE_THRESHOLD = 3\nexport const SWIPE_MAX_ELAPSED_TIME = 220\n\nfunction persistEvent(event: React.PointerEvent | PointerEvent) {\n  'persist' in event && typeof event.persist === 'function' && event.persist()\n}\n\nexport class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  readonly ingKey = 'dragging'\n  readonly stateKey = 'drag'\n\n  // TODO add back when setPointerCapture is widely wupported\n  // https://caniuse.com/#search=setPointerCapture\n  private setPointerCapture = (event: React.PointerEvent | PointerEvent) => {\n    // don't perform pointere capture when user wants to use touch events or\n    // when a pointerLockElement exists as this would throw an error\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { target, pointerId } = event\n    if (target && 'setPointerCapture' in target) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.addEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      // @ts-expect-error\n      target.setPointerCapture(pointerId)\n    }\n    this.updateGestureState({ _dragTarget: target, _dragPointerId: pointerId })\n  }\n\n  private releasePointerCapture = () => {\n    if (this.config.useTouch || document.pointerLockElement) return\n\n    const { _dragTarget, _dragPointerId } = this.state\n    if (_dragPointerId && _dragTarget && 'releasePointerCapture' in _dragTarget) {\n      // this would work in the DOM but doesn't with react three fiber\n      // target.removeEventListener('pointermove', this.onDragChange, this.controller.config.eventOptions)\n      if (!('hasPointerCapture' in _dragTarget) || _dragTarget.hasPointerCapture(_dragPointerId))\n        try {\n          _dragTarget.releasePointerCapture(_dragPointerId)\n        } catch (e) {}\n    }\n  }\n\n  private preventScroll = (event: TouchEvent) => {\n    if (this.state._dragPreventScroll && event.cancelable) {\n      event.preventDefault()\n    }\n  }\n\n  private getEventId = (event: any): number => {\n    if (this.config.useTouch) return event.changedTouches[0].identifier\n    return event.pointerId\n  }\n\n  private isValidEvent = (event: any) => {\n    // if we were using pointer events only event.isPrimary === 1 would suffice\n    return this.state._pointerId === this.getEventId(event)\n  }\n\n  private shouldPreventWindowScrollY =\n    this.config.experimental_preventWindowScrollY && this.controller.supportsTouchEvents\n\n  private setUpWindowScrollDetection = (event: React.PointerEvent | PointerEvent) => {\n    persistEvent(event)\n    // we add window listeners that will prevent the scroll when the user has started dragging\n    updateWindowListeners(\n      this.controller,\n      this.stateKey,\n      [\n        ['touchmove', this.preventScroll],\n        ['touchend', this.clean.bind(this)],\n        ['touchcancel', this.clean.bind(this)],\n      ],\n      { passive: false }\n    )\n    this.setTimeout(this.startDrag.bind(this), 250, event)\n  }\n\n  private setUpDelayedDragTrigger = (event: React.PointerEvent | PointerEvent) => {\n    this.state._dragDelayed = true\n    persistEvent(event)\n    this.setTimeout(this.startDrag.bind(this), this.config.delay, event)\n  }\n\n  private setStartState = (event: React.PointerEvent | PointerEvent) => {\n    const values = getPointerEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerId: this.getEventId(event), // setting pointerId locks the gesture to this specific event\n    })\n\n    this.updateGestureState(this.getMovement(values))\n  }\n\n  onDragStart = (event: React.PointerEvent | PointerEvent): void => {\n    addEventIds(this.controller, event)\n    if (!this.enabled || this.state._active) return\n\n    this.setStartState(event)\n    this.setPointerCapture(event as PointerEvent)\n\n    if (this.shouldPreventWindowScrollY) this.setUpWindowScrollDetection(event)\n    else if (this.config.delay > 0) this.setUpDelayedDragTrigger(event)\n    else this.startDrag(event, true) // we pass the values to the startDrag event\n  }\n\n  startDrag(event: React.PointerEvent | PointerEvent, onDragIsStart: boolean = false) {\n    // startDrag can happen after a timeout, so we need to check if the gesture is still active\n    // as the user might have lift up the pointer in between.\n\n    if (\n      // if the gesture isn't active (probably means)\n      !this.state._active ||\n      // if the drag has already started we should ignore subsequent attempts\n      this.state._dragStarted\n    )\n      return\n\n    if (!onDragIsStart) this.setStartState(event)\n    this.updateGestureState({ _dragStarted: true, _dragPreventScroll: true, cancel: this.onCancel })\n    this.clearTimeout()\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: PointerEvent): void => {\n    if (\n      // if the gesture was canceled or\n      this.state.canceled ||\n      // if onDragStart wasn't fired or\n      !this.state._active ||\n      // if the event pointerId doesn't match the one that initiated the drag\n      !this.isValidEvent(event) ||\n      // if the event has the same timestamp as the previous event\n      // note that checking type equality is ONLY for tests ¯\\_(ツ)_/¯\n      (this.state._lastEventType === event.type && event.timeStamp === this.state.timeStamp)\n    )\n      return\n\n    let values\n\n    if (document.pointerLockElement) {\n      const { movementX, movementY } = event\n      values = addV(this.transform([movementX, movementY]), this.state.values)\n    } else values = getPointerEventValues(event, this.transform)\n\n    const kinematics = this.getKinematics(values, event)\n\n    // if startDrag hasn't fired\n    if (!this.state._dragStarted) {\n      // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n      if (this.state._dragDelayed) {\n        this.startDrag(event)\n        return\n      }\n      // if the user wants to prevent vertical window scroll when user starts dragging\n      if (this.shouldPreventWindowScrollY) {\n        if (!this.state._dragPreventScroll && kinematics.axis) {\n          // if the user is dragging horizontally then we should allow the drag\n          if (kinematics.axis === 'x') {\n            this.startDrag(event)\n          } else {\n            this.state._active = false\n            return\n          }\n        } else return\n      } else return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    const genericPayload = getGenericPayload(this, event)\n\n    // This verifies if the drag can be assimilated to a tap by checking\n    // if the real distance of the drag (ie not accounting for the threshold) is\n    // greater than the TAP_DISTANCE_THRESHOLD.\n    const realDistance = calculateDistance(kinematics._movement!)\n    let { _dragIsTap } = this.state\n    if (_dragIsTap && realDistance >= TAP_DISTANCE_THRESHOLD) _dragIsTap = false\n\n    this.updateGestureState({ ...genericPayload, ...kinematics, _dragIsTap })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: PointerEvent): void => {\n    removeEventIds(this.controller, event)\n\n    // if the event pointerId doesn't match the one that initiated the drag\n    // we don't want to end the drag\n    if (!this.isValidEvent(event)) return\n    this.clean()\n\n    // if the gesture is no longer active (ie canceled)\n    // don't do anything\n    if (!this.state._active) return\n    this.state._active = false\n\n    const tap = this.state._dragIsTap\n    const [vx, vy] = this.state.velocities\n    const [mx, my] = this.state.movement\n    const [ix, iy] = this.state._intentional\n    const [svx, svy] = this.config.swipeVelocity\n    const [sx, sy] = this.config.swipeDistance\n    const sd = this.config.swipeDuration\n\n    const endState = {\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n    }\n\n    const swipe: [number, number] = [0, 0]\n\n    if (endState.elapsedTime < sd) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy)\n    }\n\n    this.updateSharedState({ buttons: 0 })\n    this.updateGestureState({ ...endState, tap, swipe })\n    this.fireGestureHandler(this.config.filterTaps && tap === true)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._dragStarted = false\n    this.releasePointerCapture()\n    clearWindowListeners(this.controller, this.stateKey)\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ canceled: true, _active: false })\n    this.updateSharedState({ buttons: 0 })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n\n  onClick = (event: React.UIEvent | UIEvent): void => {\n    if (!this.state._dragIsTap) event.stopPropagation()\n  }\n\n  addBindings(bindings: any): void {\n    if (this.config.useTouch) {\n      addBindings(bindings, 'onTouchStart', this.onDragStart)\n      addBindings(bindings, 'onTouchMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onTouchEnd', this.onDragEnd)\n      addBindings(bindings, 'onTouchCancel', this.onDragEnd)\n    } else {\n      addBindings(bindings, 'onPointerDown', this.onDragStart)\n      addBindings(bindings, 'onPointerMove', this.onDragChange) // this is needed for react-three-fiber\n      addBindings(bindings, 'onPointerUp', this.onDragEnd)\n      addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n    }\n\n    if (this.config.filterTaps) {\n      const handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture'\n      addBindings(bindings, handler, this.onClick)\n    }\n  }\n}\n","import DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport { Vector2, WebKitGestureEvent } from '../types'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventValues,\n  getWheelEventValues,\n  getWebkitGestureEventValues,\n  getTouchIds,\n} from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings, addEventIds, removeEventIds } from '../Controller'\n\nconst ZOOM_CONSTANT = 7\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\nexport class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  readonly ingKey = 'pinching'\n  readonly stateKey = 'pinch'\n\n  onPinchStart = (event: React.TouchEvent | TouchEvent) => {\n    addEventIds(this.controller, event)\n    const touchIds = this.controller.touchIds\n\n    if (!this.enabled) return\n\n    if (this.state._active) {\n      // check that the pointerIds that initiated the gesture\n      // are still enabled. This is useful for when the page\n      // loses track of the pointers (minifying gesture on iPad).\n      if (this.state._pointerIds.every(id => touchIds.has(id))) return\n      // something was wrong with the pointers but we let it go.\n    }\n    // until we reach two fingers on the target don't react\n    if (touchIds.size < 2) return\n    const _pointerIds = Array.from(touchIds).slice(0, 2) as [number, number]\n\n    const { values, origin } = getTwoTouchesEventValues(event, _pointerIds, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      _pointerIds,\n      cancel: this.onCancel,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: React.TouchEvent | TouchEvent): void => {\n    const { canceled, _active } = this.state\n    if (\n      canceled ||\n      !_active ||\n      // if the event has the same timestamp as the previous event\n      event.timeStamp === this.state.timeStamp\n    )\n      return\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n    try {\n      const { values, origin } = getTwoTouchesEventValues(event, this.state._pointerIds, this.transform)\n      const kinematics = this.getKinematics(values, event)\n\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...kinematics,\n        origin,\n      })\n\n      this.fireGestureHandler()\n    } catch (e) {\n      this.onPinchEnd(event)\n    }\n  }\n\n  onPinchEnd = (event: React.TouchEvent | TouchEvent): void => {\n    removeEventIds(this.controller, event)\n    const pointerIds = getTouchIds(event)\n\n    // if none of the lifted pointerIds is in the state pointerIds don't do anything\n    if (this.state._pointerIds.every(id => !pointerIds.includes(id))) return\n\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    if (this.state.canceled) return\n    this.updateGestureState({ _active: false, canceled: true })\n    setTimeout(() => this.fireGestureHandler(), 0)\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const values = getWebkitGestureEventValues(event, this.transform)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n      cancel: this.onCancel,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    // this normalizes the values of the Safari's WebKitEvent by calculating\n    // the delta and then multiplying it by a constant.\n    const values = getWebkitGestureEventValues(event, this.transform)\n    values[0] =\n      (values[0] - (this.state.event as WebKitGestureEvent).scale) * WEBKIT_DISTANCE_SCALE_FACTOR + this.state.values[0]\n\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...kinematics,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    this.clean()\n    if (!this.state._active) return\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getMovement(this.state.values),\n      _active: false,\n      origin: [event.clientX, event.clientY] as Vector2, // only used on dekstop\n    })\n    this.fireGestureHandler()\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: React.WheelEvent | WheelEvent) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: React.WheelEvent | WheelEvent) => {\n    const [, delta_d] = getWheelEventValues(event, this.transform)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    // ZOOM_CONSTANT is based on Safari trackpad natural zooming\n    const _delta_d = -delta_d * ZOOM_CONSTANT\n    // new distance is the previous state distance added to the delta\n    const d = prev_d + _delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [_delta_d, a] as Vector2,\n    }\n  }\n\n  onWheel = (event: React.WheelEvent | WheelEvent): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: React.WheelEvent | WheelEvent): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (event.cancelable) event.preventDefault()\n    else if (process.env.NODE_ENV === 'development') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event, this.state.values),\n      ...getGenericPayload(this, event, true),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.cancelable) event.preventDefault()\n\n    this.updateSharedState(getGenericEventData(event))\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (\n      this.controller.config.domTarget &&\n      !this.controller.supportsTouchEvents &&\n      this.controller.supportsGestureEvents\n    ) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart)\n      addBindings(bindings, 'onGestureChange', this.onGestureChange)\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd)\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart)\n      addBindings(bindings, 'onTouchMove', this.onPinchChange)\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd)\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd)\n      addBindings(bindings, 'onWheel', this.onWheel)\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, sign, subV } from '../utils/math'\nimport { Vector2, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  protected getInternalMovement(values: [number, number?], state: GestureState<T>): Vector2 {\n    const prev_a = state.values[1]\n    // not be defined if ctrl+wheel is used for zoom only\n    let [d, a = prev_a] = values\n\n    let delta_a = a - prev_a\n    let next_turns = state.turns\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a)\n    return subV([d, a - 360 * next_turns], state.initial)\n  }\n\n  getKinematics(values: Vector2, event: React.UIEvent | UIEvent): PartialGestureState<T> {\n    const state = this.getMovement(values)\n    const turns = (values[1] - state._movement![1] - this.state.initial[1]) / 360\n    const dt = event.timeStamp - this.state.timeStamp!\n    const { distance, velocity, ...kinematics } = calculateAllKinematics(state.movement!, state.delta!, dt)\n    return { turns, ...state, ...kinematics }\n  }\n\n  protected mapStateValues(state: GestureState<T>): Omit<PartialGestureState<T>, 'event'> {\n    return { da: state.values, vdva: state.velocities } as Omit<PartialGestureState<T>, 'event'>\n  }\n}\n\n/**\n * @param dangle is a small change of variable on \"lifting\" of the circle.\n * It's expected to be small and cannot be greater than 270 or under -270\n */\nexport function fixContinuity(dangle: number) {\n  dangle -= Math.round(dangle / 360) * 360\n  if (dangle > 270) return dangle - 360\n  if (dangle < -270) return dangle + 360\n  return dangle\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  readonly ingKey = 'wheeling'\n  readonly stateKey = 'wheel'\n  debounced = true\n\n  handleEvent = (event: React.WheelEvent | WheelEvent): void => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return\n    if (!this.enabled) return\n\n    this.setTimeout(this.onEnd)\n    this.updateSharedState(getGenericEventData(event))\n\n    const values = addV(getWheelEventValues(event, this.transform), this.state.values)\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movement = this.getMovement(values)\n      const geometry = calculateAllGeometry(movement.delta!)\n\n      this.updateGestureState(movement)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const movement = this.getMovement(this.state.values)\n    this.updateGestureState(movement)\n    this.updateGestureState({ _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onWheel', this.handleEvent)\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  readonly ingKey = 'moving'\n  readonly stateKey = 'move'\n\n  debounced = true\n\n  onMove = (event: React.PointerEvent | PointerEvent): void => {\n    if (!this.enabled) return\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getStartGestureState(this, values, event),\n      ...getGenericPayload(this, event, true),\n    })\n\n    this.updateGestureState(this.getMovement(values))\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: React.PointerEvent | PointerEvent): void => {\n    this.updateSharedState(getGenericEventData(event))\n    const values = getPointerEventValues(event, this.transform)\n\n    this.updateGestureState({\n      ...getGenericPayload(this, event),\n      ...this.getKinematics(values, event),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    const values = this.state.values\n    this.updateGestureState(this.getMovement(values))\n    this.updateGestureState({ velocities: [0, 0], velocity: 0, _active: false })\n    this.fireGestureHandler()\n  }\n\n  hoverTransform = () => {\n    return this.controller.config.hover!.transform || this.controller.config.transform\n  }\n\n  onPointerEnter = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const values = getPointerEventValues(event, this.hoverTransform())\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...getGenericPayload(this, event, true),\n        args: this.args,\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: React.PointerEvent | PointerEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n    if (!this.controller.config.hover!.enabled) return\n\n    const values = getPointerEventValues(event, this.hoverTransform())\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...getGenericPayload(this, event),\n      args: this.args,\n      values,\n      active: false,\n    }\n\n    this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n  }\n\n  addBindings(bindings: any): void {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove)\n    }\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter)\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave)\n    }\n  }\n}\n","import CoordinatesRecognizer from './CoordinatesRecognizer'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateAllGeometry } from '../utils/math'\nimport { getStartGestureState, getGenericPayload } from './Recognizer'\nimport { addBindings } from '../Controller'\n\nexport class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  readonly ingKey = 'scrolling'\n  readonly stateKey = 'scroll'\n  debounced = true\n\n  handleEvent = (event: React.UIEvent | UIEvent): void => {\n    if (!this.enabled) return\n\n    this.clearTimeout()\n    this.setTimeout(this.onEnd)\n\n    const values = getScrollEventValues(event, this.transform)\n    this.updateSharedState(getGenericEventData(event))\n\n    if (!this.state._active) {\n      this.updateGestureState({\n        ...getStartGestureState(this, values, event, this.state.values),\n        ...getGenericPayload(this, event, true),\n      })\n\n      const movementDetection = this.getMovement(values)\n      const geometry = calculateAllGeometry(movementDetection.delta!)\n\n      this.updateGestureState(movementDetection)\n      this.updateGestureState(geometry)\n    } else {\n      this.updateGestureState({\n        ...getGenericPayload(this, event),\n        ...this.getKinematics(values, event),\n      })\n    }\n\n    this.fireGestureHandler()\n  }\n\n  onEnd = (): void => {\n    this.clean()\n    if (!this.state._active) return\n    this.updateGestureState({ ...this.getMovement(this.state.values), _active: false, velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(bindings: any): void {\n    addBindings(bindings, 'onScroll', this.handleEvent)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport { buildComplexConfig } from './buildConfig'\nimport {\n  InternalConfig,\n  InternalHandlers,\n  UserHandlers,\n  UseGestureConfig,\n  Handlers,\n  EventTypes,\n  AnyGestureEventTypes,\n} from '../types'\nimport { RecognizersMap } from '../recognizers/Recognizer'\nimport { DragRecognizer } from '../recognizers/DragRecognizer'\nimport { MoveRecognizer } from '../recognizers/MoveRecognizer'\nimport { PinchRecognizer } from '../recognizers/PinchRecognizer'\nimport { ScrollRecognizer } from '../recognizers/ScrollRecognizer'\nimport { WheelRecognizer } from '../recognizers/WheelRecognizer'\n\nexport function wrapStart(fn: Function) {\n  return function (this: any, { first }: any) {\n    if (first) fn.apply(this, arguments)\n  }\n}\n\nexport function wrapEnd(fn: Function) {\n  return function (this: any, { last }: any) {\n    if (last) fn.apply(this, arguments)\n  }\n}\n\nconst RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/\n\nfunction sortHandlers(handlers: object) {\n  const native: any = {}\n  const handle: any = {}\n  const actions = new Set()\n\n  for (let key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch)\n      handle[key] = (handlers as any)[key]\n    } else {\n      native[key] = (handlers as any)[key]\n    }\n  }\n\n  return [handle, native, actions]\n}\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<T extends AnyGestureEventTypes = EventTypes>(\n  _handlers: Handlers<T>,\n  config: UseGestureConfig = {}\n) {\n  const [handlers, nativeHandlers, actions] = sortHandlers(_handlers)\n\n  RecognizersMap.set('drag', DragRecognizer)\n  RecognizersMap.set('hover', MoveRecognizer)\n  RecognizersMap.set('move', MoveRecognizer)\n  RecognizersMap.set('pinch', PinchRecognizer)\n  RecognizersMap.set('scroll', ScrollRecognizer)\n  RecognizersMap.set('wheel', WheelRecognizer)\n\n  const mergedConfig: InternalConfig = buildComplexConfig(config, actions)\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag')\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel')\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll')\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove')\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch')\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover\n\n  return useRecognizers<UseGestureConfig>(internalHandlers, mergedConfig, nativeHandlers)\n}\n\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\ntype HandlerKey = 'onDrag' | 'onPinch' | 'onWheel' | 'onMove' | 'onScroll' | 'onHover'\nfunction includeStartEndHandlers(handlers: Partial<UserHandlers>, handlerKey: HandlerKey) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n","import {\n  InternalConfig,\n  UseMoveConfig,\n  UseHoverConfig,\n  UseDragConfig,\n  UsePinchConfig,\n  UseScrollConfig,\n  UseWheelConfig,\n} from '../types'\n\nimport {\n  getInternalGenericOptions,\n  getInternalCoordinatesOptions,\n  getInternalDragOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\n\nimport { UseGestureConfig } from '../types'\n\nexport function _buildMoveConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseMoveConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.move = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildHoverConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseHoverConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.hover = { enabled: true, ...rest }\n  return opts\n}\n\nexport function _buildDragConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseDragConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.drag = getInternalDragOptions(rest)\n  return opts\n}\n\nexport function _buildPinchConfig({ domTarget, eventOptions, window, enabled, ...rest }: UsePinchConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.pinch = getInternalDistanceAngleOptions(rest)\n  return opts\n}\n\nexport function _buildScrollConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseScrollConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.scroll = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function _buildWheelConfig({ domTarget, eventOptions, window, enabled, ...rest }: UseWheelConfig) {\n  const opts: InternalConfig = getInternalGenericOptions({ domTarget, eventOptions, window, enabled })\n  opts.wheel = getInternalCoordinatesOptions(rest)\n  return opts\n}\n\nexport function buildComplexConfig(config: UseGestureConfig = {}, actions: Set<string> = new Set()) {\n  const { drag, wheel, move, scroll, pinch, hover, eventOptions, window, transform, domTarget, enabled } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions({\n    domTarget,\n    eventOptions,\n    transform,\n    window,\n    enabled,\n  })\n\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag)\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move)\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  if (actions.has('onHover')) mergedConfig.hover = { enabled: true, ...hover }\n\n  return mergedConfig\n}\n"],"names":["addV","v1","v2","map","v","i","subV","calculateDistance","movement","Math","hypot","apply","calculateAllGeometry","delta","dl","alpha","direction","distance","calculateAllKinematics","dt","beta","velocity","velocities","sign","x","Number","rubberband","dimension","constant","abs","Infinity","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","noop","chainFns","fns","Array","_len","_key","arguments","length","result","_step","_iterator","_createForOfIteratorHelperLoose","done","this","ensureVector","fallback","undefined","Error","isArray","assignDefault","Object","assign","valueFn","_len2","args","_key2","resolveWith","config","resolvers","_i","_Object$entries","entries","_Object$entries$_i","key","resolver","call","supportsTouchEvents","window","getEventTouches","event","type","changedTouches","targetTouches","getTouchIds","from","t","identifier","getGenericEventData","buttons","shiftKey","altKey","metaKey","ctrlKey","identity","xy","getPointerEventValues","transform","touchEvents","_ref","clientX","clientY","getTwoTouchesEventValues","pointerIds","touches","filter","includes","A","_Array$from$filter","B","dx","dy","cx","cy","values","atan2","PI","origin","getWheelEventValues","deltaX","deltaY","deltaMode","getWebkitGestureEventValues","scale","rotation","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","_extends","axis","lockDirection","bounds","state","left","_value2$left","right","_value2$right","top","_value2$top","bottom","_value2$bottom","isBrowser","document","createElement","InternalGenericOptionsNormalizers","domTarget","_window","_x","toString","eventOptions","_temp","passive","_ref$passive","capture","_ref$capture","InternalDistanceAngleOptionsNormalizers","_value","_ref2","distanceBounds","_ref2$distanceBounds","angleBounds","_ref2$angleBounds","_distanceBounds","D","_angleBounds","InternalDragOptionsNormalizers","useTouch","supportsTouch","supportsPointer","experimental_preventWindowScrollY","_k","_ref3","filterTaps","_ref3$filterTaps","_ref3$lockDirection","_ref3$axis","swipeVelocity","swipeDistance","swipeDuration","delay","getInternalGenericOptions","getInternalCoordinatesOptions","getInternalDistanceAngleOptions","getInternalDragOptions","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_threshold","_lastEventType","_dragStarted","_dragPreventScroll","_dragIsTap","_dragDelayed","intentional","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","down","locked","drag","_pointerId","vxvy","tap","swipe","pinch","_pointerIds","da","vdva","turns","wheel","move","scroll","RecognizersMap","Map","identity$1","Recognizer","controller","debounced","setTimeout","callback","ms","clearTimeout","_this","timeouts","stateKey","concat","fireGestureHandler","forceFlag","clean","prev_active","next_active","ingKey","size","touchIds","mapStateValues","pointerLockElement","newMemo","handler","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","_this$state","wasIntentional","prevMovement","_T","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","_rubberband","computeRubberband","handlers","Vx","Vy","Rx","Ry","X1","_bounds$","X2","Y1","_bounds$2","Y2","getGenericPayload","isStartEvent","getStartGestureState","_ref4","initialFn","_state","Controller","classes","Set","supportsGestureEvents","GestureEvent","e","bind","bindings","RecognizerClass","addBindings","eventKey","nativeRefs","_loop","domListeners","getDomTargetFromConfig","removeListeners","takeAll","name","slice","toLowerCase","push","addListeners","updateDomListeners","props","captureString","_i2","_Object$entries2","_Object$entries2$_i","fnsArray","getPropsListener","effect","forEach","el","_controller$config","windowListeners","clearAllWindowListeners","addEventIds","add","pointerId","removeEventIds","id","array","splice","_ref5","current","fn","listeners","options","_step2","_iterator2","_step2$value","eventName","eventHandler","addEventListener","_step3","_iterator3","_step3$value","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","get","hover","resolveClasses","React","deprecationNoticeForDomTarget","process","CoordinatesRecognizer","_Recognizer","absX","_movement$map","absY","getKinematics","persistEvent","persist","DragRecognizer","_CoordinatesRecognize","setPointerCapture","target","_dragTarget","_dragPointerId","releasePointerCapture","hasPointerCapture","preventScroll","cancelable","preventDefault","getEventId","isValidEvent","shouldPreventWindowScrollY","setUpWindowScrollDetection","updateWindowListeners","_assertThisInitialized","startDrag","setUpDelayedDragTrigger","setStartState","onDragStart","onDragChange","movementX","movementY","kinematics","genericEventData","genericPayload","realDistance","onDragEnd","vx","_this$state$velocitie","vy","mx","_this$state$movement","my","ix","_this$state$_intentio","iy","svx","_this$config$swipeVel","svy","sx","_this$config$swipeDis","sy","sd","endState","prototype","clearWindowListeners","onCancel","onClick","stopPropagation","_inheritsLoose","_proto","onDragIsStart","PinchRecognizer","_DistanceAngleRecogni","onPinchStart","every","has","_getTwoTouchesEventVa","onPinchChange","_getTwoTouchesEventVa2","onPinchEnd","onGestureStart","onGestureChange","_this$state2","onGestureEnd","wheelShouldRun","getWheelValuesFromEvent","delta_d","prev_d","_this$state$values","prev_a","_delta_d","a","onWheel","onWheelEnd","onWheelChange","onWheelStart","_this$getWheelValuesF","_this$getWheelValuesF2","d","_values$","delta_a","next_turns","_objectWithoutPropertiesLoose","WheelRecognizer","handleEvent","onEnd","geometry","MoveRecognizer","onMove","onMoveEnd","onMoveChange","onMoveStart","hoverTransform","onPointerEnter","onPointerLeave","ScrollRecognizer","currentTarget","scrollX","_event$currentTarget","scrollY","scrollLeft","scrollTop","getScrollEventValues","movementDetection","RE_NOT_NATIVE","useGesture","_handlers","_native","handle","actions","test","RegExp","lastMatch","sortHandlers","_sortHandlers","set","mergedConfig","_config","buildComplexConfig","includeStartEndHandlers","onHover","handlerKey","startKey","endKey"],"sourceRoot":""}